source(output(
		match_id as integer,
		inning as integer,
		batting_team as string,
		bowling_team as string,
		over as integer,
		ball as integer,
		batter as string,
		bowler as string,
		non_striker as string,
		batsman_runs as integer,
		extra_runs as integer,
		total_runs as integer,
		extras_type as string,
		is_wicket as integer,
		player_dismissed as string,
		dismissal_kind as string,
		fielder as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	format: 'parquet') ~> source1
source(output(
		id as integer,
		season as string,
		city as string,
		date as string,
		match_type as string,
		player_of_match as string,
		venue as string,
		team1 as string,
		team2 as string,
		toss_winner as string,
		toss_decision as string,
		winner as string,
		result as string,
		result_margin as string,
		target_runs as string,
		target_overs as string,
		super_over as string,
		method as string,
		umpire1 as string,
		umpire2 as string
	),
	allowSchemaDrift: true,
	validateSchema: false,
	ignoreNoFilesFound: false,
	format: 'parquet') ~> source2
source1 aggregate(groupBy(match_id,
		batter),
	batsman_total_runs = sum(batsman_runs)) ~> aggregate1
aggregate1, source2 join(match_id == id,
	joinType:'inner',
	matchType:'exact',
	ignoreSpaces: false,
	broadcast: 'auto')~> join1
join1 select(mapColumn(
		match_id,
		batter,
		batsman_total_runs,
		season,
		city,
		date,
		match_type,
		player_of_match,
		venue,
		team1,
		team2,
		toss_winner,
		toss_decision,
		winner,
		result,
		result_margin,
		target_runs
	),
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> select1
select1 sink(allowSchemaDrift: true,
	validateSchema: false,
	format: 'parquet',
	umask: 0022,
	preCommands: [],
	postCommands: [],
	skipDuplicateMapInputs: true,
	skipDuplicateMapOutputs: true) ~> sink1